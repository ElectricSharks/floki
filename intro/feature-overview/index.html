<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Feature Overview &middot; floki</title>

    <meta name="description" content="">

    <meta name="generator" content="Hugo 0.59.0" />
    <meta name="twitter:card" content="summary">
    
    <meta name="twitter:title" content="Feature Overview &middot; floki">
    <meta name="twitter:description" content="">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Feature Overview &middot; floki">
    <meta property="og:description" content="">

    <link href='//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Oxygen:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/pure-min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/pure/0.6.0/grids-responsive-min.css">

    <link rel="stylesheet" href='https://metaswitch.github.io/floki/css/all.min.css'>
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

    <link rel="alternate" type="application/rss+xml" title="floki" href='https://metaswitch.github.io/floki/index.xml' />
</head>
<body>


<div id="layout" class="pure-g">
    <div class="sidebar pure-u-1 pure-u-md-1-4">
    <div class="header">
        <hgroup>
            <h1 class="brand-title"><a href="https://metaswitch.github.io/floki">floki</a></h1>
            <h2 class="brand-tagline"></h2>
        </hgroup>

        <nav class="nav">
            <ul class="nav-list">
                
                
                <li class="nav-item">
                    <a class="pure-button" href="https://github.com/Metaswitch/floki">
                        <i class="fa fa-github-alt"></i> Github
                    </a>
                </li>
                
                
                
                <li class="nav-item">
                    <a class="pure-button" href='https://metaswitch.github.io/floki/index.xml'>
                        <i class="fa fa-rss"></i> rss
                    </a>
                </li>
            </ul>
        </nav>
    </div>
</div>


    <div class="content pure-u-1 pure-u-md-3-4">
        <div>
            
            <div class="posts">
                <h1 class="content-subhead">06 Apr 2019, 20:22</h1>
                <section class="post">
                    <header class="post-header">

                        <a href="https://metaswitch.github.io/floki/intro/feature-overview/" class="post-title">Feature Overview</a>

                        <p class="post-meta">
                            
                            
                        </p>
                    </header>
                    
                    <div class="post-share">
                        <div class="post-share-links">
                            <h4 style="">Share</h4>
                            
                            
                            
                            
                        </div>
                    </div>
                    
                    <div class="post-description">
                        

<p><code>floki</code> aims to provide reproducible and shareable build tooling. It does this by helping you run docker containers interactively from a declarative yaml file.</p>

<p>The ideal workflow is</p>

<ul>
<li>clone the source repository</li>
<li>run <code>floki</code></li>
<li>get to work</li>
</ul>

<p><code>floki</code> has a number of features to help achieve this. The following outlines these features.</p>

<h1 id="container-images">Container images</h1>

<p><code>floki</code> offers a couple of ways to configure the container image to use.</p>

<h2 id="prebuilt-images">Prebuilt images</h2>

<p>Using a prebuilt image (e.g. one from dockerhub or a docker registry) is as simple as providing its name as a top-level key in <code>floki.yaml</code>:</p>

<pre><code class="language-yaml">image: debian:sid
</code></pre>

<p><code>floki</code> will use docker to pull this image if you need it.</p>

<p>Custom registries can be used by configuring <code>docker</code> to use these registries. <code>floki</code> defers to <code>docker</code> to locate and pull images.</p>

<h2 id="build-an-image">Build an image</h2>

<p><code>floki</code> can use an image built from a <code>Dockerfile</code> in source tree. It&rsquo;s easiest to see an example of <code>floki.yaml</code> to see how to configure this.</p>

<pre><code class="language-yaml">image:
  build:
    name: foo                    # Will build the image with name foo:floki
    dockerfile: Dockerfile.foo   # Relative location in source tree; defaults to Dockerfile
    context: .                   # Defaults to .
    target: builder              # Target to use, for multi-stage dockerfiles (optional)
</code></pre>

<h2 id="referencing-a-key-in-another-yaml-file">Referencing a key in another yaml file</h2>

<p><code>floki</code> can use an image by reference to another yaml file. This can help keep local development environments synced with a CI environment.</p>

<pre><code class="language-yaml">image:
  yaml:
    file: .gitlab-ci.yaml
    key: variables.RUST-IMAGE
</code></pre>

<h2 id="updating-an-image">Updating an image</h2>

<p><code>floki pull</code> forces a pull of the container specified in <code>image</code>. While it is better to version images properly, this can be used when tracking a <code>latest</code> tag, or similar.</p>

<h1 id="setting-the-shell">Setting the shell</h1>

<p>Different containers require different shells, so <code>floki</code> allows you to configure this. Sometimes you will want a different shell to run the <code>init</code> commands to the shell presented to the user, and so <code>floki</code> also allows you to set an outer (used for <code>init</code>) and inner (used by the user) shell.</p>

<p>The default shell is <code>sh</code>.</p>

<h2 id="single-shell">Single shell</h2>

<p>A shell can be set for a container using the top-level <code>shell</code> key:</p>

<pre><code class="language-yaml">image: alpine:latest
shell: sh
</code></pre>

<h2 id="inner-and-outer-shell">Inner and outer shell</h2>

<p>A different shell can be used for initialization and the interactive shell provided to the user.</p>

<pre><code class="language-yaml">image: alpine:latest
shell:
  inner: bash
  outer: sh
init:
  - apk update &amp;&amp; apk install bash
</code></pre>

<p>A useful use case here is if you want to run the container with the same user as on the host. <code>floki</code> exposes the user id and user group id in environment variables, so you can add a user to the running container and switch to the new user in the inner shell:</p>

<pre><code class="language-yaml">image: foo:latest
shell:
  inner: bash
  outer: switch_user
init:
  - add_new_user $FLOKI_HOST_UID $FLOKI_HOST_GID
</code></pre>

<p>The commands to make the above work depend on the container you are running. <code>floki</code> just provides the tools to allow you to make it happen.</p>

<h1 id="docker-in-docker">Docker-in-docker</h1>

<p>Docker-in-docker (<code>dind</code>) can be enabled by setting the top-level <code>dind</code> key to <code>true</code>.</p>

<pre><code class="language-yaml">image: foo:bar
dind: true
</code></pre>

<p>Note that the docker CLI tools are still required in the container, and the docker host is a linked container, with the working directory mounted in the same place as the interactive container.</p>

<p>The precise <code>dind</code> image can also be set</p>

<pre><code class="language-yaml">dind:
  image: docker:stable-dind
</code></pre>

<p>This helps properly pin and version the docker-in-docker container.</p>

<h1 id="floki-volumes">Floki volumes</h1>

<p><code>floki</code> has the ability to use volumes for caching build artifacts between runs of the container (amongst other things). Volumes can be configured in <code>floki.yaml</code>:</p>

<pre><code class="language-yaml">volumes:
  cargo-registry:
    mount: /home/rust/.cargo/registry
</code></pre>

<p>The key names the volume (it can be any valid yaml name), while the <code>mount</code> key specifies where the volume will be mounted inside the <code>floki</code> container.</p>

<p>It&rsquo;s also possible to share volumes across different <code>floki.yaml</code>s. For example, you may want to share a <code>cargo</code> registry across all Rust build containers. These shared volumes are identified by the name given to the volume.</p>

<pre><code class="language-yaml">volumes:
  cargo-registry:
    shared: true
    mount: /home/rust/.cargo/registry
</code></pre>

<p><code>floki</code> creates directories on the host to back these volumes in <code>~/.floki/volumes</code>. Non-shared volumes are given names unique to the source directory.</p>

<h1 id="environment-forwarding">Environment forwarding</h1>

<h2 id="user-details">User details</h2>

<p><code>floki</code> captures the host user details in environment variables, and forwards these into the running container.</p>

<ul>
<li><code>FLOKI_HOST_UID</code> is set to the host user&rsquo;s user id (the output of <code>id -u</code>)</li>
<li><code>FLOKI_HOST_GID</code> is set to the host user&rsquo;s group id (the output of <code>id -g</code>)</li>
</ul>

<p>These can be used to configure users in the container dynamically. This can be a little fiddly, especially if the container already uses a non-root user with the same id as the host user.</p>

<h2 id="host-working-directory">Host working directory</h2>

<p>The host path to the mounted directory is forwarded into the <code>floki</code> container as an environment variable, <code>FLOKI_HOST_MOUNTDIR</code>.</p>

<p>You can set where this directory is mounted in the container using the <code>mount</code> key in <code>floki.yaml</code>.</p>

<h2 id="ssh-agent">SSH agent</h2>

<p>Sometimes it is useful to be able to pull dependencies from source code management servers for builds. To make this easier to do in an automated fashion, <code>floki</code> can forward and <code>ssh-agent</code> socket into the container, and expose its path through <code>SSH_AUTH_SOCK</code>.</p>

<pre><code class="language-yaml">forward_ssh_agent: true
</code></pre>

<p>You will need to have an <code>ssh-agent</code> running on the host before launching <code>floki</code>.</p>

<h1 id="sandboxed-commands-with-floki-run">Sandboxed commands with floki run</h1>

<p><code>floki</code> also allows single commands to be run, rather than dropping into an interactive shell.</p>

<pre><code class="language-shell">$ floki run ls
floki.yaml
</code></pre>

<p>Note that if you have configured an inner shell, the command will run within the inner shell.</p>

<h1 id="escaping-with-docker-switches">Escaping with <code>docker_switches</code></h1>

<p><code>floki</code> also allows you to pass additional switches to the underlying docker command, for example to forward port <code>8080</code> to the host.</p>

<pre><code class="language-yaml">image: debian:sid
docker_switches:
  - -p
  - 8080:8080
init:
  - echo &quot;Welcome to your server container!&quot;
</code></pre>

<p>Note that use of <code>docker_switches</code> may reduce the reproducibility and shareability of your <code>floki.yaml</code> (for instance it could be used to mount a volume with a specific host path that works on no other machines).</p>

<p>Nonetheless, it is useful to be able to add arbitrary switches in a pinch, just to be able to get something working.
If there are things you can add with <code>docker_switches</code> which are reproducible and shareable, please raise a feature request, or go ahead and implement it yourself!</p>

                    </div>
                    
                </section>
            </div>
            <div class="footer">
    <div class="pure-menu pure-menu-horizontal pure-menu-open">
        <ul>
            <li>Powered by <a class="hugo" href="https://gohugo.io/" target="_blank">hugo</a></li>
        </ul>
    </div>
</div>
<script src='https://metaswitch.github.io/floki/js/all.min.js'></script>

        </div>
    </div>
</div>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', '', 'auto');
ga('send', 'pageview');

</script>

</body>
</html>
